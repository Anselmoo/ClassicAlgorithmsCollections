<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>String and Arrays · ClassicAlgorithmsCollections.jl</title><link rel="canonical" href="https://Anselmoo.github.io/ClassicAlgorithmsCollections/man/StringsAndArrays/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ClassicAlgorithmsCollections.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../guide/">Guide</a></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../SortingAndSearching/">Sorting and Searching</a></li><li class="is-active"><a class="tocitem" href>String and Arrays</a><ul class="internal"><li><a class="tocitem" href="#Strings"><span>Strings</span></a></li><li><a class="tocitem" href="#Array-Analysis"><span>Array-Analysis</span></a></li></ul></li><li><a class="tocitem" href="../Graph/">Graph</a></li><li><a class="tocitem" href="../Bits/">BITS</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Algorithms</a></li><li class="is-active"><a href>String and Arrays</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>String and Arrays</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/master/docs/src/man/StringsAndArrays.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Strings"><a class="docs-heading-anchor" href="#Strings">Strings</a><a id="Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Strings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.reverse_pure_string" href="#ClassicAlgorithmsCollections.reverse_pure_string"><code>ClassicAlgorithmsCollections.reverse_pure_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reverse_pure_string(text::String)</code></pre><p>Reverse only the non-special characters (alphabet: &#39;a&#39;, to &#39;z&#39; and &#39;A&#39; to &#39;Z&#39;) and letting the rest untouched. For this purpose, <code>reverse_pure_string</code> is scanning through the string as an array, and if the current character is not special, it will reverse the elements by swapping; vice versa, if the current character is a special element, the boundaries will be modified.</p><p><strong>Arguments</strong></p><ul><li><code>text::String</code>: String with special character like !,&lt;#</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; string = &quot;a!!!b.c79.d,e&#39;f,ghi3###&quot;&quot;
julia&gt; ClassicAlgorithmsCollectionsreverse_pure_string(string)
&quot;a!!!b.c79.d,e&#39;f,ghi3###&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/b677fd7c4df7282920c121f60c7ad22bcb1987a8/src/StringAndArray.jl#LL1-L22">source</a></section></article><h2 id="Array-Analysis"><a class="docs-heading-anchor" href="#Array-Analysis">Array-Analysis</a><a id="Array-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.zigzag_ordering" href="#ClassicAlgorithmsCollections.zigzag_ordering"><code>ClassicAlgorithmsCollections.zigzag_ordering</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">zigzag_ordering(array::Array{Int64,1})</code></pre><p><code>zigzag_ordering</code> reorders an unsorted array in the zigzag fashion. This procedure implies that between every second step a break will be generated by switching the <code>flag-boolean</code>.</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; arr = [4, 3, 7, 8, 6, 2, 1, 10, 13, 3]
julia&gt; ClassicAlgorithmsCollections.zigzag_ordering(arr)
[3, 7, 4, 8, 2, 6, 1, 13, 3, 10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/b677fd7c4df7282920c121f60c7ad22bcb1987a8/src/StringAndArray.jl#LL47-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.count_triplet_elements" href="#ClassicAlgorithmsCollections.count_triplet_elements"><code>ClassicAlgorithmsCollections.count_triplet_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">count_triplet_elements(array::Array{Int64,1}, sum::Int64)</code></pre><p>Counting the number of three elements in the array, which sum is equal to the reference sum.</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array</li><li><code>array::Array{Int64,1}</code>: Refernece sum</li></ul><p><strong>Examples</strong></p><p>```julia-repl julia&gt; import ClassicAlgorithmsCollections julia&gt; arr = [5, 1, 3, 4, 7] julia&gt; sum = 12 julia&gt; ClassicAlgorithmsCollections.count<em>triplet</em>elements(arr, sum) 2</p><p><strong>Notes:</strong></p><hr/><p>This should be implemented recursively instead of using three for-loops because it will allow using any conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/b677fd7c4df7282920c121f60c7ad22bcb1987a8/src/StringAndArray.jl#LL88-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.count_pythagorean_elements" href="#ClassicAlgorithmsCollections.count_pythagorean_elements"><code>ClassicAlgorithmsCollections.count_pythagorean_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">count_pythagorean_elements(array::Array{Int64,1})</code></pre><p>Counting the number of <code>Pythagorean</code>-elements in the array, which sum is equal to A^2 + B^2 = C^2.</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; arr = [5, 1, 3, 4, 17, 8, 15, 2, 2, 13 ,12]
julia&gt; ClassicAlgorithmsCollections.count_pythagorean_elements(arr, sum)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/b677fd7c4df7282920c121f60c7ad22bcb1987a8/src/StringAndArray.jl#LL134-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.find_maxlength_subarray" href="#ClassicAlgorithmsCollections.find_maxlength_subarray"><code>ClassicAlgorithmsCollections.find_maxlength_subarray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_maxlength_subarray(array::Array{Int64,1})</code></pre><p>Find the maximum length of a subarray with a given continuous depending sequence of numbers. For this reason, the minimum and maximum element in every subarray will be tracked and compared with the incremental distance. So if the difference of the value is equal to the difference of the increment in the array, the length will be updated.</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; arr = [10, 12, 11, 9, 13, 14, 17, 18, 15]
julia&gt; ClassicAlgorithmsCollections.find_maxlength_subarray(arr)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/b677fd7c4df7282920c121f60c7ad22bcb1987a8/src/StringAndArray.jl#LL179-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.find_smallest_nonelement" href="#ClassicAlgorithmsCollections.find_smallest_nonelement"><code>ClassicAlgorithmsCollections.find_smallest_nonelement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_smallest_nonelement(array::Array{Int64,1})</code></pre><p>Returns the smallest number of a sorted array that cannot be represented as sum of subset of elements from this array.</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; arr = [1, 2, 5, 10, 20, 40]
julia&gt; ClassicAlgorithmsCollections.find_smallest_nonelement(arr)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/b677fd7c4df7282920c121f60c7ad22bcb1987a8/src/StringAndArray.jl#LL227-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.sum_of_postive_gradients" href="#ClassicAlgorithmsCollections.sum_of_postive_gradients"><code>ClassicAlgorithmsCollections.sum_of_postive_gradients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sum_of_postive_gradients(array::Array{Int64,1}, m = nothing, n = nothing)</code></pre><p>Estimates the sum of all positive gradients in array-sequence, calling the function itself recursively. Every time if the <code>array[j] &gt; array[i]</code> will be check, it will test the monotony of the previous of the following elements.</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array</li><li><code>m::Int64</code>: index for the nested <code>for-loops</code>; optional</li><li><code>n::Int64</code>: index for the nested <code>for-loops</code>; optional</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; arr =  arr = [100, 180, 260, 310, 40, 535, 695]
julia&gt; ClassicAlgorithmsCollections.sum_of_postive_gradients(arr)
865</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/b677fd7c4df7282920c121f60c7ad22bcb1987a8/src/StringAndArray.jl#LL299-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.combinations_of_2arrays" href="#ClassicAlgorithmsCollections.combinations_of_2arrays"><code>ClassicAlgorithmsCollections.combinations_of_2arrays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">combinations_of_2arrays(array_1::Array{Int64,1}, array_2::Array{Int64,1}))</code></pre><p>Provides all combinations of sorted arrays with an increasing number of elements. Original idea</p><p><strong>Arguments</strong></p><ul><li><code>array_1::Array{Int64,1}</code>: First sorted array</li><li><code>array_2::Array{Int64,1}</code>: Second sorted array</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; arr_1 = [10, 15, 25]
julia&gt; arr_2 = [5, 20, 30]
julia&gt; ClassicAlgorithmsCollections.combinations_of_2arrays(arr_1, arr_2)
[10, 20]
[10, 20, 25, 30]
[10, 30]
[15, 20]
[15, 20, 25, 30]
[15, 30]
[25, 30]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/b677fd7c4df7282920c121f60c7ad22bcb1987a8/src/StringAndArray.jl#LL446-L472">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../SortingAndSearching/">« Sorting and Searching</a><a class="docs-footer-nextpage" href="../Graph/">Graph »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 11 November 2020 20:45">Wednesday 11 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
