<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sorting and Searching · ClassicAlgorithmsCollections.jl</title><link rel="canonical" href="https://Anselmoo.github.io/ClassicAlgorithmsCollections/man/SortingAndSearching/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ClassicAlgorithmsCollections.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../guide/">Guide</a></li><li><span class="tocitem">Algorithms</span><ul><li class="is-active"><a class="tocitem" href>Sorting and Searching</a><ul class="internal"><li><a class="tocitem" href="#Array-Search"><span>Array-Search</span></a></li><li><a class="tocitem" href="#Array-Sorting"><span>Array-Sorting</span></a></li></ul></li><li><a class="tocitem" href="../Graph/">Graph</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Algorithms</a></li><li class="is-active"><a href>Sorting and Searching</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sorting and Searching</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/master/docs/src/man/SortingAndSearching.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Array-Search"><a class="docs-heading-anchor" href="#Array-Search">Array-Search</a><a id="Array-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Search" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.binary_search" href="#ClassicAlgorithmsCollections.binary_search"><code>ClassicAlgorithmsCollections.binary_search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">binary_search(array::Array{Int64,1}, target::Int64)</code></pre><p>The binary search algorithm (BSA) finds a target value&#39;s position within a sorted array by  using a half-interval cut per each cycle. Thus, the BSA compares the target value to the  value of the array&#39;s middle element. In the case of inequality, the half array-piece in  which the target cannot be will be erased. Next, the search continues on the remaining  half array-piece and starts taking the middle element to compare it to the target value. This procedure has to be continued until the target value is found. The search may have to  be stopped with a remaining empty half array-piece; consequently, the target is not in the  array. For more information see: <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">https://en.wikipedia.org/wiki/Binary<em>search</em>algorithm</a></p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Sorted array of integers</li><li><code>target::Int64</code>: Target-value to find the position </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [10,11, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47]
julia&gt; target = 12
julia&gt; ClassicAlgorithmsCollections.binary_search(arr, target)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/e0873baa9170213cc530dbe42ecff9902684dcec/src/SortingAndSearching.jl#LL1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.binary_pivot_search" href="#ClassicAlgorithmsCollections.binary_pivot_search"><code>ClassicAlgorithmsCollections.binary_pivot_search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">binary_pivot_search(array::Array{Int64,1}, target::Int64)</code></pre><p>The idea is to find the pivot point for finding the target in an unsorted array. For this  reason, the array has to be divided into two subarrays; a binary search is performed on  the subarrays.</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li><li><code>target::Int64</code>: Target-value to find the position </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [2, 5, 4, 7, 2, 8, 9, 3, 10, 2]
julia&gt; target = 3
julia&gt; ClassicAlgorithmsCollections.binary_pivot_search(arr, target)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/e0873baa9170213cc530dbe42ecff9902684dcec/src/SortingAndSearching.jl#LL49-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.interpolation_searching" href="#ClassicAlgorithmsCollections.interpolation_searching"><code>ClassicAlgorithmsCollections.interpolation_searching</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interpolation_searching(array::Array{Int64,1}, target::Int64)</code></pre><p>The Interpolation search algorithm (ISA) finds a target-position in a sorted array by using  a numerical procedure. The sorting procedure uses a linear fitting for finding the target  position of the remaining search space in the array in more detail. The array&#39;s target  position is calculated by the straight slope between the lowest and largest boundary of the  remaining array and the lowest array position itself during each optimization cycle. If the  target-position cannot be found, the array-space will be shrink for the lower or higher  boundary region based on a comparison. For more information see: <a href="https://en.wikipedia.org/wiki/Interpolation_search">https://en.wikipedia.org/wiki/Interpolation_search</a></p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Sorted array of integers</li><li><code>target::Int64</code>: Target-value to find the position </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [10,11, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47]
julia&gt; target = 12
julia&gt; ClassicAlgorithmsCollections.interpolation_searching(arr, target)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/e0873baa9170213cc530dbe42ecff9902684dcec/src/SortingAndSearching.jl#LL104-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.closest_pair_searching" href="#ClassicAlgorithmsCollections.closest_pair_searching"><code>ClassicAlgorithmsCollections.closest_pair_searching</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">closest_pair_searching(array::Array{Int64,1}, target::Int64)</code></pre><p>Finding the closet pair of values for a given target in a sorted array. For this reason,  the distance between a pair of of values has to be minimazied with respect to the target. For more information see: <a href="https://en.wikipedia.org/wiki/Closest_pair_of_points_problem">https://en.wikipedia.org/wiki/Closest<em>pair</em>of<em>points</em>problem</a></p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Sorted array of integers</li><li><code>target::Int64</code>: Target-value to find the position </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [10, 22, 28, 29, 30, 40]
julia&gt; target = 56
julia&gt; ClassicAlgorithmsCollections.closest_pair_searching(arr, target)
(28, 29)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/e0873baa9170213cc530dbe42ecff9902684dcec/src/SortingAndSearching.jl#LL170-L190">source</a></section></article><h2 id="Array-Sorting"><a class="docs-heading-anchor" href="#Array-Sorting">Array-Sorting</a><a id="Array-Sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Sorting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.bubble_sorting" href="#ClassicAlgorithmsCollections.bubble_sorting"><code>ClassicAlgorithmsCollections.bubble_sorting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bubble_sorting(array::Array{Int64,1})</code></pre><p>The Bubble sorting algorithm (BSA) is a primitive sorting algorithm that repeatedly steps  through the array by using a double for-loop with n and n-1 size. During the walkthrough,  the BSA compares adjacent elements and swaps wrong ordered elements until the array is  sorted. For more information see: <a href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.bubble_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/e0873baa9170213cc530dbe42ecff9902684dcec/src/SortingAndSearching.jl#LL223-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.insertion_sorting" href="#ClassicAlgorithmsCollections.insertion_sorting"><code>ClassicAlgorithmsCollections.insertion_sorting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insertion_sorting(array::Array{Int64,1})</code></pre><p>The insertion sorting algorithm builds the final sorted array by inserting elements that are  greater than the key, to one position ahead of their current position step one item at a  time. For more information see: <a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.insertion_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/e0873baa9170213cc530dbe42ecff9902684dcec/src/SortingAndSearching.jl#LL261-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.merge_sorting" href="#ClassicAlgorithmsCollections.merge_sorting"><code>ClassicAlgorithmsCollections.merge_sorting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">merge_sorting(array::Array{Int64,1})</code></pre><p>The merge sort algorithms (MSA) are a comparison-based sorting algorithm, which is referred  to as the divide and conquer algorithms.  The stable sort implementation is a widely used  method for the MSA, which means that the order of equal elements is the same in the input  and output. In the current implementation, a top-down implementation is used; however, a  Bottom-up implementation can be used, too. In the top-down implementation, the MSA  recursively splits the array into subarrays until the subarray size is &lt; 2, merging those  subarrays to produce a sorted array by using a new function <code>merge</code>. The back copying is  blocked by alternating the direction of the merge with each recursion. For more information  see: <a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.merge_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/e0873baa9170213cc530dbe42ecff9902684dcec/src/SortingAndSearching.jl#LL340-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.heap_sorting" href="#ClassicAlgorithmsCollections.heap_sorting"><code>ClassicAlgorithmsCollections.heap_sorting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">heap_sorting(array::Array{Int64,1})</code></pre><p>As a comparison-based sorting algorithm, the heapsort algorithm (HSA) divides its input  into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by  extracting the largest element from it and inserting it into the sorted region. A specialty  is that the HSA keeps the unsorted region in a heap data structure to find the largest  element in each step more quickly. In more detail, in the first part of the HSA  (while-loop), the largest value has to be found and set to position one. In the second part  of the HSA (while-loop), the array&#39;s first and largest value has to be swap to the last  index of the array, and the swapping-procedure starts again for a new interval n-1. For  more information see: <a href="https://en.wikipedia.org/wiki/Heapsort">https://en.wikipedia.org/wiki/Heapsort</a></p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.heap_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/e0873baa9170213cc530dbe42ecff9902684dcec/src/SortingAndSearching.jl#LL426-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.quick_sorting" href="#ClassicAlgorithmsCollections.quick_sorting"><code>ClassicAlgorithmsCollections.quick_sorting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quick_sorting(array::Array{Int64,1}, low = nothing, high = nothing)</code></pre><p>The quick sort algorithm (QSA) works by selecting a pivot element from the array and  partitioning the other elements into two subarrays, according to whether they are less than  or greater than the pivot-window. Then the sorting of subarrays is recursively organized.  This procedure repeatedly happens until each subarray is organized; consequently, the  subarrays&#39; merging is an organized array. For more information see:  <a href="https://en.wikipedia.org/wiki/Quicksort#Parallelization">https://en.wikipedia.org/wiki/Quicksort#Parallelization</a></p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li><li><code>low::Int64</code>: Lowest index of the unsorted array or subarray</li><li><code>high::Int64</code>: Highes index of the unsorted array or subarray</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.quick_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/e0873baa9170213cc530dbe42ecff9902684dcec/src/SortingAndSearching.jl#LL513-L536">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/">« Guide</a><a class="docs-footer-nextpage" href="../Graph/">Graph »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 20 September 2020 14:47">Sunday 20 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
