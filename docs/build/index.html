<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example · ClassicAlgorithmsCollections.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ClassicAlgorithmsCollections.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Example</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h1><p>Example Julia package repo.</p><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.binary_pivot_search-Tuple{Array{Int64,1},Int64}" href="#ClassicAlgorithmsCollections.binary_pivot_search-Tuple{Array{Int64,1},Int64}"><code>ClassicAlgorithmsCollections.binary_pivot_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">binary_pivot_search(array::Array{Int64,1}, target::Int64)</code></pre><p>The idea is to find the pivot point for finding the target in an unsorted array. For this  reason, the array has to be divided into two subarrays; a binary search is performed on  the subarrays.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li><li><code>target::Int64</code>: Target-value to find the position </li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [2, 5, 4, 7, 2, 8, 9, 3, 10, 2]
julia&gt; target = 3
julia&gt; ClassicAlgorithmsCollections.binary_pivot_search(arr, target)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L49-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.binary_search-Tuple{Array{Int64,1},Int64}" href="#ClassicAlgorithmsCollections.binary_search-Tuple{Array{Int64,1},Int64}"><code>ClassicAlgorithmsCollections.binary_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">binary_search(array::Array{Int64,1}, target::Int64)</code></pre><p>The binary search algorithm (BSA) finds a target value&#39;s position within a sorted array by  using a half-interval cut per each cycle. Thus, the BSA compares the target value to the  value of the array&#39;s middle element. In the case of inequality, the half array-piece in  which the target cannot be will be erased. Next, the search continues on the remaining  half array-piece and starts taking the middle element to compare it to the target value. This procedure has to be continued until the target value is found. The search may have to  be stopped with a remaining empty half array-piece; consequently, the target is not in the  array. For more information see: https://en.wikipedia.org/wiki/Binary<em>search</em>algorithm</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Sorted array of integers</li><li><code>target::Int64</code>: Target-value to find the position </li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [10,11, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47]
julia&gt; target = 12
julia&gt; ClassicAlgorithmsCollections.binary_search(arr, target)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.boogle_word_check-Tuple{Dict{Int64,Array{String,1}},Array{String,1}}" href="#ClassicAlgorithmsCollections.boogle_word_check-Tuple{Dict{Int64,Array{String,1}},Array{String,1}}"><code>ClassicAlgorithmsCollections.boogle_word_check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boogle_word_check(
    graph::Dict{Int64,Array{String,1}},
    reference_words::Array{String,1},
)</code></pre><p>For finding words (<code>reference_words</code>) in a field of chars, the boogle word check algorithm  goes for every single char up and down to see if the sum of the chars build a word  contained in th refernce word list. For this porpose the  Depth First Traversal algorithm  in function find_word is used.</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{String,1}}</code>: Graph of the connected nodes of chars, which can build the words</li><li><code>reference_words::Array{String,1}</code>: Reference words to search for</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; word_list = [&quot;GEEKS&quot;, &quot;FOR&quot;, &quot;QUIZ&quot;, &quot;GO&quot;]
julia&gt; graph_boogle = Dict(
        1 =&gt; [&quot;G&quot;, &quot;I&quot;, &quot;Z&quot;],
        2 =&gt; [&quot;U&quot;, &quot;E&quot;, &quot;K&quot;],
        3 =&gt; [&quot;Q&quot;, &quot;S&quot;, &quot;E&quot;],
        4 =&gt; [&quot;D&quot;, &quot;O&quot;, &quot;P&quot;],
        5 =&gt; [&quot;F&quot;, &quot;O&quot;, &quot;R&quot;],
        )
julia&gt; ClassicAlgorithmsCollections.boogle_word_check(graph_boogle, word_list) ==
[&quot;GEEKS&quot;, &quot;QUIZ&quot;, &quot;FOR&quot;]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L737-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.breadth_first_search-Tuple{Dict{Int64,Array{Int64,1}},Int64}" href="#ClassicAlgorithmsCollections.breadth_first_search-Tuple{Dict{Int64,Array{Int64,1}},Int64}"><code>ClassicAlgorithmsCollections.breadth_first_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">breadth_first_search(graph::Dict{Int64,Array{Int64,1}}, start::Int64)</code></pre><p>The breadth-first search (BFS) is an algorithm dedicated to traversing or searching for  tree or graph data structures. It starts at a specified tree root (start) for exploring  all connected neighbor nodes. The important feature is that the BFS automatically leaves  the present depth and passes on to the next nodes at a deeper level. BFS is queue-based. For more information see: https://en.wikipedia.org/wiki/Breadth-first_search</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Int64,1}}</code>: Graph of the connected nodes</li><li><code>start::Int64</code>: Startpoint (first selected vertex) of the graph-traveling process</li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; graph = Dict(1=&gt; [2, 3], 2=&gt; [3], 3=&gt; [1, 4], 4=&gt; [4])
julia&gt; ClassicAlgorithmsCollections.breadth_first_search(graph, 3)
[3, 1, 4, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L70-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.bridge_check-Tuple{Dict{Int64,Array{Int64,1}},Int64,Array{Int64,1},Array{Bool,1},Array{Int64,1},Array{Int64,1},Array{Int64,1},Int64}" href="#ClassicAlgorithmsCollections.bridge_check-Tuple{Dict{Int64,Array{Int64,1}},Int64,Array{Int64,1},Array{Bool,1},Array{Int64,1},Array{Int64,1},Array{Int64,1},Int64}"><code>ClassicAlgorithmsCollections.bridge_check</code></a> — <span class="docstring-category">Method</span></header><section><div><p>bridge_check(     graph::Dict{Int64,Array{Int64,1}},     u::Int64,     result::Array{Int64,1},     visited::Array{Bool,1},     parent::Array{Int64,1},     low::Array{Int64,1},     disc::Array{Int64,1},     time::Int64, )</p><p>For finding a bridge belonging to the current vertex, the algorithm has to remove firstly  one by one all edges. Next, the algorithm has to see if the removal of an edge causes a  disconnected graph. If yes, for the current pair of <code>u</code> and <code>v</code>, are a bridge between the  endpoints is found.</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Tuple{Int64,Int64},1}}</code>: Graph of the connected nodes</li><li><code>u::Int64</code>: Next to visit vertex</li><li><code>result::Array{Int64,1}</code>: Results of the graph bridges; start and endpoint of the bridge</li><li><code>visited::Array{Bool,1}</code>: Visited vertex</li><li><code>parent::Array{Int64,1}</code>: Parent vertices in DFS tree&#39;</li><li><code>low::Array{Int64,1}</code>: Lowest vertex reachable from subtree </li><li><code>disc::Array{Int64,1}</code>: Discovery time of the visited vertex </li><li><code>time::Int64</code>: Current time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L522-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.bubble_sorting-Tuple{Array{Int64,1}}" href="#ClassicAlgorithmsCollections.bubble_sorting-Tuple{Array{Int64,1}}"><code>ClassicAlgorithmsCollections.bubble_sorting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bubble_sorting(array::Array{Int64,1})</code></pre><p>The Bubble sorting algorithm (BSA) is a primitive sorting algorithm that repeatedly steps  through the array by using a double for-loop with n and n-1 size. During the walkthrough,  the BSA compares adjacent elements and swaps wrong ordered elements until the array is  sorted. For more information see: https://en.wikipedia.org/wiki/Bubble_sort</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.bubble_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L223-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.closest_pair_searching-Tuple{Array{Int64,1},Int64}" href="#ClassicAlgorithmsCollections.closest_pair_searching-Tuple{Array{Int64,1},Int64}"><code>ClassicAlgorithmsCollections.closest_pair_searching</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">closest_pair_searching(array::Array{Int64,1}, target::Int64)</code></pre><p>Finding the closet pair of values for a given target in a sorted array. For this reason,  the distance between a pair of of values has to be minimazied with respect to the target. For more information see: https://en.wikipedia.org/wiki/Closest<em>pair</em>of<em>points</em>problem</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Sorted array of integers</li><li><code>target::Int64</code>: Target-value to find the position </li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [10, 22, 28, 29, 30, 40]
julia&gt; target = 56
julia&gt; ClassicAlgorithmsCollections.closest_pair_searching(arr, target)
(28, 29)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L170-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.depth_first_search-Tuple{Dict{Int64,Array{Int64,1}},Int64}" href="#ClassicAlgorithmsCollections.depth_first_search-Tuple{Dict{Int64,Array{Int64,1}},Int64}"><code>ClassicAlgorithmsCollections.depth_first_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">depth_first_search(graph::Dict{Int64,Array{Int64,1}}, start::Int64)</code></pre><p>The depth-first search (DFS) is an algorithm dedicated to traversing or searching for  tree or graph data structures. It starts at a specified tree root (start) for exploring  as far as possible at each branch. Afterthat the BFS starts automatically backtracking.  DFS is stack-based.  For more information see: https://en.wikipedia.org/wiki/Depth-first_search</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Int64,1}}</code>: Graph of the connected nodes</li><li><code>start::Int64</code>: Startpoint (first selected vertex) of the graph-traveling process</li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; graph = Dict(1=&gt; [2, 3], 2=&gt; [3], 3=&gt; [1, 4], 4=&gt; [4])
julia&gt; ClassicAlgorithmsCollections.breadth_first_search(graph, 3)
[3, 1, 2, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L169-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.dfs_recrusive-Tuple{Dict{Int64,Array{Int64,1}},Int64,Array{Bool,1},Array{Int64,1}}" href="#ClassicAlgorithmsCollections.dfs_recrusive-Tuple{Dict{Int64,Array{Int64,1}},Int64,Array{Bool,1},Array{Int64,1}}"><code>ClassicAlgorithmsCollections.dfs_recrusive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dfs_recrusive(
    graph::Dict{Int64,Array{Int64,1}},
    start::Int64,
    visited::Array{Bool,1},
    solution::Array{Int64,1},
)</code></pre><p>The recursively call of the dfs_recrusive is essential for exploring each single branch  of the graph.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Int64,1}}</code>: Graph of the connected nodes</li><li><code>start::Int64</code>: Startpoint (first selected vertex) of the graph-traveling process</li><li><code>visited::Array{Bool,1}</code>: Visited nodes of the graph</li><li><code>solution::Array{Int64,1}</code>: Solution of the raph-traveling proces</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L129-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.find_global_maximum-Tuple{Dict{Int64,Array{Int64,1}}}" href="#ClassicAlgorithmsCollections.find_global_maximum-Tuple{Dict{Int64,Array{Int64,1}}}"><code>ClassicAlgorithmsCollections.find_global_maximum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_global_maximum(graph::Dict{Int64,Array{Int64,1}})</code></pre><p>Find the total global maximum based on a comparsion between the intial vertex  (<code>global_maximum = 0</code>), the current dictionary key, and the accesible vertexes from  the array-list (value).</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Int64,1}}</code>: Graph of the connected nodes</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.find_global_maximum_complex-Tuple{Dict{Int64,Array{Tuple{Int64,Int64},1}}}" href="#ClassicAlgorithmsCollections.find_global_maximum_complex-Tuple{Dict{Int64,Array{Tuple{Int64,Int64},1}}}"><code>ClassicAlgorithmsCollections.find_global_maximum_complex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_global_maximum_complex(graph::Dict{Int64,Array{Tuple{Int64,Int64},1}})</code></pre><p><code>find_global_maximum_complex</code> is similar to <code>find_global_maximum</code> instead is desigend  for handling graphs with weights.    </p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Tuple{Int64,Int64},1}}</code>: Graph of the connected nodes with weights</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L34-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.find_parent_in_cycle-Tuple{Array{Int64,1},Int64,Int64}" href="#ClassicAlgorithmsCollections.find_parent_in_cycle-Tuple{Array{Int64,1},Int64,Int64}"><code>ClassicAlgorithmsCollections.find_parent_in_cycle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_parent_in_cycle(parent::Array{Int64,1}, i::Int64, ref_key::Int64)</code></pre><p>The find parent algorithm is a recursive function to find the subeset of an item i for  graph test of being cycling.</p><p><strong>Arguments</strong></p><ul><li><code>parent::Array{Int64,1}</code>: Array of the subset of the items</li><li><code>i::Int64</code>: Index of the parents-item</li><li><code>ref_key::Int64</code>: Reference Key, which can be for example the total size of the subset</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L319-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.find_parent_in_spanning_tree-Tuple{Array{Int64,1},Int64}" href="#ClassicAlgorithmsCollections.find_parent_in_spanning_tree-Tuple{Array{Int64,1},Int64}"><code>ClassicAlgorithmsCollections.find_parent_in_spanning_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_parent_in_spanning_tree(parent::Array{Int64,1}, i::Int64, ref_key::Int64)</code></pre><p>The find parent algorithm is a recursive function to find the subeset of an item i for  graph test of having a spanning tree.</p><p><strong>Arguments</strong></p><ul><li><code>parent::Array{Int64,1}</code>: Array of the subset of the items</li><li><code>i::Int64</code>: Index of the parents-item</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L338-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.find_word-Tuple{Dict{Int64,Array{String,1}},Array{Bool,2},Int64,Int64,Int64,Int64,String,Array{String,1},Array{String,1}}" href="#ClassicAlgorithmsCollections.find_word-Tuple{Dict{Int64,Array{String,1}},Array{Bool,2},Int64,Int64,Int64,Int64,String,Array{String,1},Array{String,1}}"><code>ClassicAlgorithmsCollections.find_word</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_word(
    graph::Dict{Int64,Array{String,1}},
    visited::Array{Bool,2},
    i::Int64,
    j::Int64,
    size_v::Int64,
    size_h::Int64,
    current_word::String,
    reference_words::Array{String,1},
    result::Array{String,1},
)</code></pre><p>Based on the Depth First Traversal algorithm, words will be find for a current char by  going through the graph up and down and keep track of the visited nodes. Important is that  the travelling happens in both direction up and down and left and right. Everythign will be  stacked in the visited list. If no word will be found the <code>current_word</code> has to be deleted. </p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{String,1}}</code>: Graph of the connected nodes of chars, which can build the words</li><li><code>visited::Array{Bool,2}</code>: List of the visited chars in the graph</li><li><code>i::Int64</code>: current row</li><li><code>j::Int64</code>: current col</li><li><code>size_v::Int64</code>: total size of rows</li><li><code>size_h::Int64</code>: total size of cols</li><li><code>current_word::String</code>: current joint word of chars</li><li><code>reference_words::Array{String,1}</code>: Reference words to search for</li><li><code>result::Array{String,1}</code>: List of the found words in the graph</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L651-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.graph_bridge_check-Tuple{Dict{Int64,Array{Int64,1}}}" href="#ClassicAlgorithmsCollections.graph_bridge_check-Tuple{Dict{Int64,Array{Int64,1}}}"><code>ClassicAlgorithmsCollections.graph_bridge_check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph_bridge_check(graph::Dict{Int64,Array{Int64,1}}))</code></pre><p>For finding a bridge or more bridges in an undirect connected graph, the kind of connection  has to be found, which can disconnect the graph by removing it. In case of disconnected  undirected graphs, the bridge is the connection which increases number of disconnected  components by removing it.</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Tuple{Int64,Int64},1}}</code>: Graph of the connected nodes</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; graph_bridge = Dict(1 =&gt; [2, 3, 4], 2 =&gt; [1, 3], 3 =&gt; [1, 2], 4 =&gt; [1, 5], 5 =&gt; [4])
julia&gt; ClassicAlgorithmsCollections.graph_bridge_check(graph_bridge)
[4 5; 1 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L601-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.graph_cycle_check-Tuple{Dict{Int64,Array{Int64,1}}}" href="#ClassicAlgorithmsCollections.graph_cycle_check-Tuple{Dict{Int64,Array{Int64,1}}}"><code>ClassicAlgorithmsCollections.graph_cycle_check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph_cycle_check(graph::Dict{Int64,Array{Int64,1}})</code></pre><p>The disjoint-set data structure principle is used to check if a direct or undirect  graph contains a cycle. For this reason, the algorithm keeps the first track of a set  of items partitioned into several disjoint (non-overlapping) subsets to find which  subset a particular item is kept. This procedure is essential to figure out if two  items are in the same subgroup. Next, the two subsets have to be merged into a single  subset. For more information see: https://en.wikipedia.org/wiki/Disjoint-set<em>data</em>structure</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Int64,1}}</code>: Graph of the connected nodes</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; graph_cycle_true = Dict(1 =&gt; [2], 2 =&gt; [3], 3 =&gt; [1, 4])
julia&gt; ClassicAlgorithmsCollections.graph_cycle_check(graph_cycle_true)
true
julia&gt; graph_cycle_false = Dict(1 =&gt; [2], 2 =&gt; [5], 3 =&gt; [1, 4])
julia&gt; ClassicAlgorithmsCollections.graph_cycle_check(graph_cycle_false)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L356-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.heap_sorting-Tuple{Array{Int64,1}}" href="#ClassicAlgorithmsCollections.heap_sorting-Tuple{Array{Int64,1}}"><code>ClassicAlgorithmsCollections.heap_sorting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">heap_sorting(array::Array{Int64,1})</code></pre><p>As a comparison-based sorting algorithm, the heapsort algorithm (HSA) divides its input  into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by  extracting the largest element from it and inserting it into the sorted region. A specialty  is that the HSA keeps the unsorted region in a heap data structure to find the largest  element in each step more quickly. In more detail, in the first part of the HSA  (while-loop), the largest value has to be found and set to position one. In the second part  of the HSA (while-loop), the array&#39;s first and largest value has to be swap to the last  index of the array, and the swapping-procedure starts again for a new interval n-1. For  more information see: https://en.wikipedia.org/wiki/Heapsort</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.heap_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L426-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.heapify-Tuple{Array{Int64,1},Int64,Int64}" href="#ClassicAlgorithmsCollections.heapify-Tuple{Array{Int64,1},Int64,Int64}"><code>ClassicAlgorithmsCollections.heapify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">heapify(array::Array{Int64,1})</code></pre><p>The heapify function merges the two subroutines for:     1) Put elements of the array in heap order     2) Repair the heap elements <code>i</code> whose root element, if is not at the index <code>largest</code> For more information see: https://en.wikipedia.org/wiki/Heapsort</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li><li><code>n::Int64</code>: Length of the array</li><li><code>::Int64</code>: Current index of the array</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L386-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.initialize_matrices-Tuple{Dict{Int64,Array{Tuple{Int64,Int64},1}}}" href="#ClassicAlgorithmsCollections.initialize_matrices-Tuple{Dict{Int64,Array{Tuple{Int64,Int64},1}}}"><code>ClassicAlgorithmsCollections.initialize_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initialize_matrices(graph::Dict{Int64,Array{Tuple{Int64,Int64},1}})</code></pre><p>Initialize the matrices for distances and pathes.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Tuple{Int64,Int64},1}}</code>: Graph of the connected nodes with weights</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L206-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.insertion_sorting-Tuple{Array{Int64,1}}" href="#ClassicAlgorithmsCollections.insertion_sorting-Tuple{Array{Int64,1}}"><code>ClassicAlgorithmsCollections.insertion_sorting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">insertion_sorting(array::Array{Int64,1})</code></pre><p>The insertion sorting algorithm builds the final sorted array by inserting elements that are  greater than the key, to one position ahead of their current position step one item at a  time. For more information see: https://en.wikipedia.org/wiki/Insertion_sort</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.insertion_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L261-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.interpolation_searching-Tuple{Array{Int64,1},Int64}" href="#ClassicAlgorithmsCollections.interpolation_searching-Tuple{Array{Int64,1},Int64}"><code>ClassicAlgorithmsCollections.interpolation_searching</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolation_searching(array::Array{Int64,1}, target::Int64)</code></pre><p>The Interpolation search algorithm (ISA) finds a target-position in a sorted array by using  a numerical procedure. The sorting procedure uses a linear fitting for finding the target  position of the remaining search space in the array in more detail. The array&#39;s target  position is calculated by the straight slope between the lowest and largest boundary of the  remaining array and the lowest array position itself during each optimization cycle. If the  target-position cannot be found, the array-space will be shrink for the lower or higher  boundary region based on a comparison. For more information see: https://en.wikipedia.org/wiki/Interpolation_search </p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Sorted array of integers</li><li><code>target::Int64</code>: Target-value to find the position </li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [10,11, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47]
julia&gt; target = 12
julia&gt; ClassicAlgorithmsCollections.interpolation_searching(arr, target)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L104-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.merge-Tuple{Array{Int64,1},Array{Int64,1}}" href="#ClassicAlgorithmsCollections.merge-Tuple{Array{Int64,1},Array{Int64,1}}"><code>ClassicAlgorithmsCollections.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge(left::Array{Int64,1}, right::Array{Int64,1}))</code></pre><p>The merge algorithms (MA) merge the subarrays <code>left</code> and <code>right</code> to produce new sorted  subarrays until there is only one subarray remaining, which will be the sorted array. For more information see: https://en.wikipedia.org/wiki/Merge_sort</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>left::Array{Int64,1}</code>: Unsorted left part of the array</li><li><code>right::Array{Int64,1}</code>: Unsorted right part of the array</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L297-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.merge_sorting-Tuple{Array{Int64,1}}" href="#ClassicAlgorithmsCollections.merge_sorting-Tuple{Array{Int64,1}}"><code>ClassicAlgorithmsCollections.merge_sorting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge_sorting(array::Array{Int64,1})</code></pre><p>The merge sort algorithms (MSA) are a comparison-based sorting algorithm, which is referred  to as the divide and conquer algorithms.  The stable sort implementation is a widely used  method for the MSA, which means that the order of equal elements is the same in the input  and output. In the current implementation, a top-down implementation is used; however, a  Bottom-up implementation can be used, too. In the top-down implementation, the MSA  recursively splits the array into subarrays until the subarray size is &lt; 2, merging those  subarrays to produce a sorted array by using a new function <code>merge</code>. The back copying is  blocked by alternating the direction of the merge with each recursion. For more information  see: https://en.wikipedia.org/wiki/Merge_sort</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.merge_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L340-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.minimum_spanning_tree-Tuple{Dict{Int64,Array{Tuple{Int64,Int64},1}}}" href="#ClassicAlgorithmsCollections.minimum_spanning_tree-Tuple{Dict{Int64,Array{Tuple{Int64,Int64},1}}}"><code>ClassicAlgorithmsCollections.minimum_spanning_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimum_spanning_tree(graph::Dict{Int64,Array{Tuple{Int64,Int64},1}}))</code></pre><p>The minimum spanning tree (MST) algorithm detects a subset of the edges of a connected,  edge-weighted undirected graph that connects all the vertices together. The MST algorithms  focus is a) to exclude any cycles and b) to find the minimum possible total edge weight,  which will create a spanning tree whose sum of edge weights is as small as possible.  The Kruskal&#39;s algorithm is used to find the minimum spanning forest of an undirected  edge-weighted graph.  For more information see: https://en.wikipedia.org/wiki/Minimum<em>spanning</em>tree and  https://en.wikipedia.org/wiki/Kruskal%27s_algorithm</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Tuple{Int64,Int64},1}}</code>: Graph of the connected nodes with the weights</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; graph_with_spanning_tree = Dict(1 =&gt; [(2, 10), (3, 6), (4, 5)], 2 =&gt; [(4, 15)], 3 =&gt; [(4, 4)]
julia&gt; ClassicAlgorithmsCollections.minimum_spanning_tree(graph_with_spanning_tree)
[3 4 4; 1 4 5; 1 2 10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L429-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.modular_exponentiation-Tuple{Int64,Int64,Int64}" href="#ClassicAlgorithmsCollections.modular_exponentiation-Tuple{Int64,Int64,Int64}"><code>ClassicAlgorithmsCollections.modular_exponentiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">modular_exponentiation(base::Int, exponent::Int, modulus::Int)</code></pre><p>Compute the residuum of the base raised to the exponent, which is divided by the modulus.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>base::Integer</code>: base</li><li><code>exponent::Integer</code>: exponent</li><li><code>modulus ::Integer</code>: modulus</li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; ClassicAlgorithmsCollections.modular_exponentiation(2, 3, 15)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/NumberTheory.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.partition-Tuple{Array{Int64,1},Int64,Int64}" href="#ClassicAlgorithmsCollections.partition-Tuple{Array{Int64,1},Int64,Int64}"><code>ClassicAlgorithmsCollections.partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partition(array::Array{Int64,1}, low::Int64, high::Int64)</code></pre><p>The partion algorithm is shuffeling the array for a given interval of low and high  boundaries.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li><li><code>low::Int64</code>: Lowest index of the unsorted array or subarray</li><li><code>high::Int64</code>: Highes index of the unsorted array or subarray</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L479-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.path_reconstruction-Tuple{Array{Int64,2},Int64,Int64}" href="#ClassicAlgorithmsCollections.path_reconstruction-Tuple{Array{Int64,2},Int64,Int64}"><code>ClassicAlgorithmsCollections.path_reconstruction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">path_reconstruction(next::Array{Int64,2}, u::Int64, v::Int64)</code></pre><p>Reconstruction of the actual path between any two endpoint vertices (u &amp; v). ...</p><p><strong>Arguments</strong></p><ul><li><code>graph::Dict{Int64,Array{Tuple{Int64,Int64},1}}</code>: Graph of the connected nodes with weights</li><li><code>u::Int64</code>: Startpoint of the to investigated path</li><li><code>v::Int64</code>: Endpoint of the to investigated path</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L238-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.quick_sorting" href="#ClassicAlgorithmsCollections.quick_sorting"><code>ClassicAlgorithmsCollections.quick_sorting</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quick_sorting(array::Array{Int64,1}, low = nothing, high = nothing)</code></pre><p>The quick sort algorithm (QSA) works by selecting a pivot element from the array and  partitioning the other elements into two subarrays, according to whether they are less than  or greater than the pivot-window. Then the sorting of subarrays is recursively organized.  This procedure repeatedly happens until each subarray is organized; consequently, the  subarrays&#39; merging is an organized array. For more information see:  https://en.wikipedia.org/wiki/Quicksort#Parallelization</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Int64,1}</code>: Unsorted array of integers</li><li><code>low::Int64</code>: Lowest index of the unsorted array or subarray</li><li><code>high::Int64</code>: Highes index of the unsorted array or subarray</li></ul><p>...</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [64, 34, 25, 12, 22, 11, 90] 
julia&gt; ClassicAlgorithmsCollections.quick_sorting(arr)
[11, 12, 22, 25, 34, 64, 90]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/SortingAndSearching.jl#L513-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.shortest_path_tree" href="#ClassicAlgorithmsCollections.shortest_path_tree"><code>ClassicAlgorithmsCollections.shortest_path_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shortest_path_tree(graph::Dict{Int64,Array{Tuple{Int64,Int64},1}}, u=nothing, v=nothing)</code></pre><p>The Shortest Path Tree (SPT) algorithm solves the shortest path problem between every  pair of vertices in a given edge-weighted directed Graph based on the Floyd–Warshall  algorithm. Optional, the SPT also provides the total parts between a start- (u) and end- point (v). For more information see: https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm</p><p><strong>Arguments</strong></p><ul><li><code>next::Array{Int64,2}</code>: Vertex matrix of the connected nodes</li><li><code>u::Int64</code>: Startpoint of the to investigated path; optional</li><li><code>v::Int64</code>: Endpoint of the to investigated path; optional</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import ClassicAlgorithmsCollections
julia&gt; graph = Dict( 1 =&gt; [(3, -2)], 2 =&gt; [(1, 4),(3, 3)], 3 =&gt; [(4, 2)], 4 =&gt; [(2, -1)]
julia&gt; ClassicAlgorithmsCollections.shortest_path_tree(graph, 2, 4)
([0 -1 -2 0; 4 0 2 4; 5 1 0 2; 3 -1 1 0], [2, 1, 3, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L266-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClassicAlgorithmsCollections.sortrows" href="#ClassicAlgorithmsCollections.sortrows"><code>ClassicAlgorithmsCollections.sortrows</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Provided by: https://discourse.julialang.org/t/sort-matrix-based-on-the-elements-of-a-specific-column/23475/5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Anselmoo/ClassicAlgorithmsCollections/blob/8aa0b7cea64dc8e22c6637a0b5a12ba4263bf5ad/src/Graph.jl#L411-L413">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 17 September 2020 18:23">Thursday 17 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
