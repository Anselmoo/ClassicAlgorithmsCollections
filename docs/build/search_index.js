var documenterSearchIndex = {"docs":
[{"location":"#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"","page":"Example","title":"Example","text":"Example Julia package repo.","category":"page"},{"location":"","page":"Example","title":"Example","text":"Modules = [ClassicAlgorithmsCollections]","category":"page"},{"location":"#ClassicAlgorithmsCollections.breadth_first_search-Tuple{Dict{Int64,Array{Int64,1}},Int64}","page":"Example","title":"ClassicAlgorithmsCollections.breadth_first_search","text":"breadth_first_search(graph::Dict{Int64,Array{Int64,1}}, start::Int64)\n\nThe breadth-first search (BFS) is an algorithm dedicated to traversing or searching for  tree or graph data structures. It starts at a specified tree root (start) for exploring  all connected neighbor nodes. The important feature is that the BFS automatically leaves  the present depth and passes on to the next nodes at a deeper level. BFS is queue-based. For more information see: https://en.wikipedia.org/wiki/Breadth-first_search\n\n...\n\nArguments\n\ngraph::Dict{Int64,Array{Int64,1}}: Graph of the connected nodes\nstart::Int64: Startpoint (first selected vertex) of the graph-traveling process\n\n...\n\nExamples\n\njulia> import ClassicAlgorithmsCollections\njulia> graph = Dict(1=> [2, 3], 2=> [3], 3=> [1, 4], 4=> [4])\njulia> ClassicAlgorithmsCollections.breadth_first_search(graph, 3)\n[3, 1, 4, 2]\n\n\n\n\n\n","category":"method"},{"location":"#ClassicAlgorithmsCollections.depth_first_search-Tuple{Dict{Int64,Array{Int64,1}},Int64}","page":"Example","title":"ClassicAlgorithmsCollections.depth_first_search","text":"depth_first_search(graph::Dict{Int64,Array{Int64,1}}, start::Int64)\n\nThe depth-first search (DFS) is an algorithm dedicated to traversing or searching for  tree or graph data structures. It starts at a specified tree root (start) for exploring  as far as possible at each branch. Afterthat the BFS starts automatically backtracking.  DFS is stack-based.  For more information see: https://en.wikipedia.org/wiki/Depth-first_search\n\n...\n\nArguments\n\ngraph::Dict{Int64,Array{Int64,1}}: Graph of the connected nodes\nstart::Int64: Startpoint (first selected vertex) of the graph-traveling process\n\n...\n\nExamples\n\njulia> import ClassicAlgorithmsCollections\njulia> graph = Dict(1=> [2, 3], 2=> [3], 3=> [1, 4], 4=> [4])\njulia> ClassicAlgorithmsCollections.breadth_first_search(graph, 3)\n[3, 1, 2, 4]\n\n\n\n\n\n","category":"method"},{"location":"#ClassicAlgorithmsCollections.dfs_recrusive-Tuple{Dict{Int64,Array{Int64,1}},Int64,Array{Bool,1},Array{Int64,1}}","page":"Example","title":"ClassicAlgorithmsCollections.dfs_recrusive","text":"dfs_recrusive(\n    graph::Dict{Int64,Array{Int64,1}},\n    start::Int64,\n    visited::Array{Bool,1},\n    solution::Array{Int64,1},\n)\n\nThe recursively call of the dfs_recrusive is essential for exploring each single branch  of the graph.\n\n...\n\nArguments\n\ngraph::Dict{Int64,Array{Int64,1}}: Graph of the connected nodes\nstart::Int64: Startpoint (first selected vertex) of the graph-traveling process\nvisited::Array{Bool,1}: Visited nodes of the graph\nsolution::Array{Int64,1}: Solution of the raph-traveling proces\n\n...\n\n\n\n\n\n","category":"method"},{"location":"#ClassicAlgorithmsCollections.find_global_maximum-Tuple{Dict{Int64,Array{Int64,1}}}","page":"Example","title":"ClassicAlgorithmsCollections.find_global_maximum","text":"find_global_maximum(graph::Dict{Int64,Array{Int64,1}})\n\nFind the total global maximum based on the intial vertex, the dictionary key, and the  accesible vertexes, the array-list.\n\n...\n\nArguments\n\ngraph::Dict{Int64,Array{Int64,1}}: Graph of the connected nodes\n\n...\n\n\n\n\n\n","category":"method"},{"location":"#ClassicAlgorithmsCollections.find_parent-Tuple{Array{Int64,1},Int64,Int64}","page":"Example","title":"ClassicAlgorithmsCollections.find_parent","text":"find_parent(parent::Array{Int64,1}, i::Int64, vertex_size::Int64)\n\nThe find parent algorithm is a recursive function to find the subeset of an item i.\n\nArguments\n\nparent::Array{Int64,1}: Array of the subset of the items\ni::Int64: Index of the item\nvertex_size::Int64: Total size of the subeset\n\n\n\n\n\n","category":"method"},{"location":"#ClassicAlgorithmsCollections.graph_cycle_check-Tuple{Dict{Int64,Array{Int64,1}}}","page":"Example","title":"ClassicAlgorithmsCollections.graph_cycle_check","text":"graph_cycle_check(graph::Dict{Int64,Array{Int64,1}})\n\nThe disjoint-set data structure principle is used to check if a direct or undirect  graph contains a cycle. For this reason, the algorithm keeps the first track of a set  of items partitioned into several disjoint (non-overlapping) subsets to find which  subset a particular item is kept. This procedure is essential to figure out if two  items are in the same subgroup. Next, the two subsets have to be merged into a single  subset. For more information see: https://en.wikipedia.org/wiki/Disjoint-setdatastructure\n\nArguments\n\ngraph::Dict{Int64,Array{Int64,1}}: Graph of the connected nodes\n\nExamples\n\njulia> import ClassicAlgorithmsCollections\njulia> graph = graph_cycle_true = Dict(1 => [2], 2 => [3], 3 => [1, 4])\njulia> ClassicAlgorithmsCollections.graph_cycle_check(graph_cycle_true)\ntrue\njulia> graph = graph_cycle_false = Dict(1 => [2], 2 => [5], 3 => [1, 4])\njulia> ClassicAlgorithmsCollections.graph_cycle_check(graph_cycle_false)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#ClassicAlgorithmsCollections.initialize_matrices-Tuple{Dict{Int64,Array{Tuple{Int64,Int64},1}}}","page":"Example","title":"ClassicAlgorithmsCollections.initialize_matrices","text":"initialize_matrices(graph::Dict{Int64,Array{Tuple{Int64,Int64},1}})\n\nInitialize the matrices for distances and pathes.\n\n...\n\nArguments\n\ngraph::Dict{Int64,Array{Tuple{Int64,Int64},1}}: Graph of the connected nodes with weights\n\n...\n\n\n\n\n\n","category":"method"},{"location":"#ClassicAlgorithmsCollections.modular_exponentiation-Tuple{Int64,Int64,Int64}","page":"Example","title":"ClassicAlgorithmsCollections.modular_exponentiation","text":"modular_exponentiation(base::Int, exponent::Int, modulus::Int)\n\nCompute the residuum of the base raised to the exponent, which is divided by the modulus.\n\n...\n\nArguments\n\nbase::Integer: base\nexponent::Integer: exponent\nmodulus ::Integer: modulus\n\n...\n\nExamples\n\njulia> import ClassicAlgorithmsCollections\njulia> ClassicAlgorithmsCollections.modular_exponentiation(2, 3, 15)\n8\n\n\n\n\n\n","category":"method"},{"location":"#ClassicAlgorithmsCollections.path_reconstruction-Tuple{Array{Int64,2},Int64,Int64}","page":"Example","title":"ClassicAlgorithmsCollections.path_reconstruction","text":"path_reconstruction(next::Array{Int64,2}, u::Int64, v::Int64)\n\nReconstruction of the actual path between any two endpoint vertices (u & v). ...\n\nArguments\n\ngraph::Dict{Int64,Array{Tuple{Int64,Int64},1}}: Graph of the connected nodes with weights\nu::Int64: Startpoint of the to investigated path\nv::Int64: Endpoint of the to investigated path\n\n...\n\n\n\n\n\n","category":"method"},{"location":"#ClassicAlgorithmsCollections.shortest_path_tree","page":"Example","title":"ClassicAlgorithmsCollections.shortest_path_tree","text":"shortest_path_tree(graph::Dict{Int64,Array{Tuple{Int64,Int64},1}}, u=nothing, v=nothing)\n\nThe Shortest Path Tree (SPT) algorithm solves the shortest path problem between every  pair of vertices in a given edge-weighted directed Graph based on the Floyd–Warshall  algorithm. Optional, the SPT also provides the total parts between a start- (u) and end- point (v). For more information see: https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm\n\nArguments\n\nnext::Array{Int64,2}: Vertex matrix of the connected nodes\nu::Int64: Startpoint of the to investigated path; optional\nv::Int64: Endpoint of the to investigated path; optional\n\nExamples\n\njulia> import ClassicAlgorithmsCollections\njulia> graph = Dict( 1 => [(3, -2)], 2 => [(1, 4),(3, 3)], 3 => [(4, 2)], 4 => [(2, -1)]\njulia> ClassicAlgorithmsCollections.shortest_path_tree(graph, 2, 4)\n([0 -1 -2 0; 4 0 2 4; 5 1 0 2; 3 -1 1 0], [2, 1, 3, 4])\n\n\n\n\n\n","category":"function"}]
}
