"""
    reverse_pure_string(text::String)

Reverse only the non-special characters (alphabet: 'a', to 'z' and 'A' to 'Z') and letting
the rest untouched. For this purpose, `reverse_pure_string` is scanning through the string
as an array, and if the current character is not special, it will reverse the elements by
swapping; vice versa, if the current character is a special element, the boundaries will be
modified.

# Arguments
- `text::String`: String with special character like !,<#


# Examples
```julia-repl
julia> import ClassicAlgorithmsCollections
julia> string = "a!!!b.c79.d,e'f,ghi3###""
julia> ClassicAlgorithmsCollectionsreverse_pure_string(string)
"a!!!b.c79.d,e'f,ghi3###""
```
"""
function reverse_pure_string(text::String)
    low = 1
    high = sizeof(text)

    text_array = collect(text)
    while low < high
        # Check if lower char is special character and change the boundary
        if !isletter(text_array[low])
            low += 1
            # Check if higher char is special character and change the boundary
        elseif !isletter(text_array[high])
            high -= 1
        else
            # Reverse the string by swapping
            text_array[low], text_array[high] = text_array[high], text_array[low]
            low += 1
            high -= 1

        end
    end
    return join(text_array)
end


"""
    zigzag_ordering(array::Array{Int64,1})

`zigzag_ordering` reorders an unsorted array in the zigzag fashion. This procedure implies
that between every second step a break will be generated by switching the `flag-boolean`.


# Arguments
- `array::Array{Int64,1}`: Unsorted array


# Examples
```julia-repl
julia> import ClassicAlgorithmsCollections
julia> arr = [4, 3, 7, 8, 6, 2, 1, 10, 13, 3]
julia> ClassicAlgorithmsCollections.zigzag_ordering(arr)
[3, 7, 4, 8, 2, 6, 1, 13, 3, 10]
```
"""
function zigzag_ordering(array::Array{Int64,1})
    # Intialize the flag
    flag = true
    for i in 1:length(array)-1
        # If flag is true, then check if next array element is greater than previous
        if flag
            if array[i] > array[i+1]
                array[i], array[i+1] = array[i+1], array[i]
            end
            # If flag is true, then check if next array element is smaller than previous
        else
            if array[i] < array[i+1]
                array[i], array[i+1] = array[i+1], array[i]
            end
        end
        # Swapt the flag after every turn
        flag = !flag
    end
    return array
end


"""
    count_triplet_elements(array::Array{Int64,1}, sum::Int64)

Counting the number of three elements in the array, which sum is equal to the reference sum.


# Arguments
- `array::Array{Int64,1}`: Unsorted array
- `array::Array{Int64,1}`: Refernece sum


# Examples
```julia-repl
julia> import ClassicAlgorithmsCollections
julia> arr = [5, 1, 3, 4, 7]
julia> sum = 12
julia> ClassicAlgorithmsCollections.count_triplet_elements(arr, sum)
2


# Notes:
---

This should be implemented recursively instead of using three for-loops because it will
allow using any conditions.

"""
function count_triplet_elements(array::Array{Int64,1}, sum::Int64)

    # Initialize result
    ans = 0
    n = length(array)

    for i in 1:n-2
        for j in i+1:n-1
            for k in j+1:n
                if (array[i] + array[j] + array[k] == sum)
                    ans += 1
                end
            end
        end
    end
    return ans
end


"""
    count_pythagorean_elements(array::Array{Int64,1})

Counting the number of `Pythagorean`-elements in the array, which sum is equal to
A^2 + B^2 = C^2.


# Arguments
- `array::Array{Int64,1}`: Unsorted array

# Examples
```julia-repl
julia> import ClassicAlgorithmsCollections
julia> arr = [5, 1, 3, 4, 17, 8, 15, 2, 2, 13 ,12]
julia> ClassicAlgorithmsCollections.count_pythagorean_elements(arr, sum)
3
```
"""
function count_pythagorean_elements(array::Array{Int64,1})

    # Initialize result
    ans = 0
    n = length(array)

    for i in 1:n-2
        for j in i+1:n-1
            for k in j+1:n
                AA = array[i]^2
                BB = array[j]^2
                CC = array[k]^2
                if (AA + BB == CC)
                    ans += 1
                elseif (AA + CC == BB)
                    ans += 1
                elseif (BB + CC == AA)
                    ans += 1
                end
            end
        end
    end
    return ans
end


"""
    find_maxlength_subarray(array::Array{Int64,1})

Find the maximum length of a subarray with a given continuous depending sequence of numbers.
For this reason, the minimum and maximum element in every subarray will be tracked and
compared with the incremental distance. So if the difference of the value is equal to the
difference of the increment in the array, the length will be updated.


# Arguments
- `array::Array{Int64,1}`: Unsorted array

# Examples
```julia-repl
julia> import ClassicAlgorithmsCollections
julia> arr = [10, 12, 11, 9, 13, 14, 17, 18, 15]
julia> ClassicAlgorithmsCollections.find_maxlength_subarray(arr)
5
```
"""
function find_maxlength_subarray(array::Array{Int64,1})

    # Initialize result
    max_len = 1
    n = length(array)
    for i in 1:n
        min_array = array[i]
        max_array = array[i]

        for j in (i+1):n
            if min_array > array[j]
                min_array = array[j]
            end
            if max_array < array[j]
                max_array = array[j]
            end
            if ((max_array - min_array) == (j - i))
                if max_len < (max_array - min_array)
                    max_len = max_array - min_array + 1
                end
            end
        end
    end
    return max_len
end


"""
    find_smallest_nonelement(array::Array{Int64,1})

Returns the smallest number of a sorted array that cannot be represented as sum of subset of
elements from this array.

# Arguments
- `array::Array{Int64,1}`: Unsorted array

# Examples
```julia-repl
julia> import ClassicAlgorithmsCollections
julia> arr = [1, 2, 5, 10, 20, 40]
julia> ClassicAlgorithmsCollections.find_smallest_nonelement(arr)
4
```
"""
function find_smallest_nonelement(array::Array{Int64,1})

    result = 1
    for i in 1:length(array)
        if array[i] <= result
            result += array[i]
        else
            break
        end
    end
    return result
end

"""
    smallest_subset4sum(array::Array{Int64,1}, target::Int64)

Returns length of smallest subarray-unit with sum greater than the target.

# Arguments
- `array::Array{Int64,1}`: Unsorted array
- `target::Int64`: Target number to reach

# Examples
```julia-repl
julia> import ClassicAlgorithmsCollections
julia> arr =  [10, 12, 11, 9, 13, 14, 17, 18, 15]
julia> ClassicAlgorithmsCollections.smallest_subarray4sum(arr)
4
```
"""
function smallest_subset4sum(array::Array{Int64,1}, target::Int64)
    n = length(array)
    min_length = n

    for i in 1:n
        current_sum = array[i]
        if current_sum > target
            return 1
        end
        for j in (i+1):n
            current_sum += array[j]
            if current_sum > target && (j - i + 1) < min_length
                min_length = (j - i + 1)
            end
        end
    end
    if min_length != n
        return min_length
    else
        return nothing
    end
end


"""
    sum_of_postive_gradients(array::Array{Int64,1}, m = nothing, n = nothing)

Estimates the sum of all positive gradients in array-sequence, calling the function itself
recursively. Every time if the `array[j] > array[i]` will be check, it will test the
monotony of the previous of the following elements.

# Arguments
- `array::Array{Int64,1}`: Unsorted array
- `m::Int64`: index for the nested `for-loops`; optional
- `n::Int64`: index for the nested `for-loops`; optional


# Examples
```julia-repl
julia> import ClassicAlgorithmsCollections
julia> arr =  arr = [100, 180, 260, 310, 40, 535, 695]
julia> ClassicAlgorithmsCollections.sum_of_postive_gradients(arr)
865
```
"""
function sum_of_postive_gradients(array::Array{Int64,1}, m = nothing, n = nothing)

    if isnothing(m) && isnothing(n)
        m = 1
        n = length(array)
    end
    gradient = 0

    for i in m:n
        for j in (i+1):n
            if array[j] > array[i]
                tmp_gradient =
                    array[j] - array[i] +
                    sum_of_postive_gradients(array, m, i - 1) +
                    sum_of_postive_gradients(array, j + 1, n)

                if tmp_gradient > gradient
                    gradient = tmp_gradient
                end
            end
        end
    end

    return gradient
end


"""
    generate_array(
        array_1::Array{Int64},
        array_2::Array{Int64},
        array_merged::Array{Int64},
        i::Int64,
        j::Int64,
        k::Int64,
        l::Int64,
        size::Int64,
        flag::Bool,
        result::Array{Any,1}
    )

`generate_array` is a modified [Breadth-First-Search]https://en.wikipedia.org/wiki/Breadth-first_search]
for generating the result-array with the possible combinations of two merged arrays with
ascending ordering.


# Arguments
- `array_1::Array{Int64}`: First sorted array
- `array_2::Array{Int64}`: Second sorted array
- `array_merged::Array{Int64}`: Merged sorted array
- `i::Int64`: Outer lower increment of first array
- `j::Int64`: Outer higher increment of first array
- `k::Int64`: Outer lower increment of second array
- `l::Int64`: Outer higher increment of second array
- `size::Int64`: Current size
- `flag::Bool`: Switching between first and second array
- `result::Array{Any,1}`: Result list of the merged arrays
"""
function generate_array(
    array_1::Array{Int64},
    array_2::Array{Int64},
    array_merged::Array{Int64},
    i::Int64,
    j::Int64,
    k::Int64,
    l::Int64,
    size::Int64,
    flag::Bool,
    result::Array{Any,1},
    )
    if flag
        if size > 1
            push!(result, array_merged[1:size])
        end
        for m in i:k
            # Define the first element
            if size < 2
                array_merged[size] = array_1[m]
                generate_array(array_1,
                array_2, array_merged, m + 1, j, k, l, size, !flag,
                result)
            else
                # Going to the third and higher element of array_1
                if array_1[m] > array_merged[size]
                    array_merged[size + 1] = array_1[m]
                    generate_array(
                        array_1,
                        array_2,
                        array_merged,
                        m + 1,
                        j,
                        k,
                        l,
                        size + 1,
                        !flag,result
                    )
                end
            end
        end

    else
        # Going to the second of array_2
        for n in j:l
            if array_2[n] > array_merged[size]
                array_merged[size + 1] = array_2[n]
                generate_array(
                    array_1,
                    array_2,
                    array_merged,
                    i,
                    n + 1,
                    k,
                    l,
                    size + 1,
                    !flag,result
                )

            end
        end

    end
    return result
end


"""
    combinations_of_2arrays(array_1::Array{Int64,1}, array_2::Array{Int64,1}))

Provides all combinations of sorted arrays with an increasing number of elements. Original
idea


# Arguments
- `array_1::Array{Int64,1}`: First sorted array
- `array_2::Array{Int64,1}`: Second sorted array

# Examples
```julia-repl
julia> import ClassicAlgorithmsCollections
julia> arr_1 = [10, 15, 25]
julia> arr_2 = [5, 20, 30]
julia> ClassicAlgorithmsCollections.combinations_of_2arrays(arr_1, arr_2)
[10, 20]
[10, 20, 25, 30]
[10, 30]
[15, 20]
[15, 20, 25, 30]
[15, 30]
[25, 30]
```
"""
function combinations_of_2arrays(array_1::Array{Int64,1}, array_2::Array{Int64,1})
    length_array_1,  length_array_2 = length(array_1),  length(array_2)
    init_array = zeros(Int64, (length_array_1 +  length_array_2))
     # Create array-list for the searching solution
    result = Array{Any,1}()
    return generate_array(
        array_1,
        array_2,
        init_array,
        1,
        1,
        length_array_1,  length_array_2,
        1,
        true,
        result
    )
end
